<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Liquid Blob</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #f0f0f0; /* Clean studio background like the image */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            color: #888;
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.7;
            user-select: none;
        }
        .instruction {
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="ui">
        <span class="instruction">Click & Drag to Round â€¢ Use Controls to Edit</span>
    </div>

    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Import OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Import lil-gui for controls -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19.1/dist/lil-gui.umd.min.js"></script>
    <!-- Import JSZip for export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // --- 1. Setup Scene ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0); // Matching the light grey background
        // Add some fog for depth
        scene.fog = new THREE.Fog(0xf0f0f0, 2, 10);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 4.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // Sharpness on high DPI
        container.appendChild(renderer.domElement);

        // --- 3. Shaders (The Magic) ---

        // Vertex Shader: Handles the "melting" shape and displacement
        const vertexShader = `
            uniform float uTime;
            uniform float uDistortion;
            uniform float uNoiseScale;
            uniform float uNoiseStrength;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying float vNoise;

            // Simplex noise function (standard GLSL)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;

                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                //   x0 = x0 - 0.0 + 0.0 * C.xxx;
                //   x1 = x0 - i1  + 1.0 * C.xxx;
                //   x2 = x0 - i2  + 2.0 * C.xxx;
                //   x3 = x0 - 1.0 + 3.0 * C.xxx;
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

                // Permutations
                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                // Gradients: 7x7 points over a square, mapped onto an octahedron.
                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
                float n_ = 0.142857142857; // 1.0/7.0
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                // Mix final noise value
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                            dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vUv = uv;
                
                // Add some noise based on time and position
                float noise = snoise(vec3(position * uNoiseScale + uTime * 0.5));
                
                // Secondary finer noise for detail
                float fineNoise = snoise(vec3(position * (uNoiseScale * 2.5) + uTime * 0.8)) * 0.2;
                
                // Combine noise
                float finalNoise = noise + fineNoise;
                vNoise = finalNoise; // Pass to fragment for coloring

                // Displace vertices along normal
                // uDistortion controls how "melted" it is (1.0 = normal, 0.0 = smooth sphere)
                vec3 newPos = position + normal * finalNoise * uNoiseStrength * uDistortion;

                // Standard vertex transform
                vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                vViewPosition = -mvPosition.xyz;
                vNormal = normalMatrix * normal;
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader: Handles the "Melting Metal" iridescence and colors
        const fragmentShader = `
            uniform float uTime;
            uniform float uMetallic;
            uniform float uGlow;
            uniform float uRoughness;
            
            // Color Uniforms
            uniform vec3 uColorBase;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying float vNoise;

            void main() {
                // Normalize vectors
                vec3 normal = normalize(vNormal);
                vec3 viewDir = normalize(vViewPosition);

                // Basic lighting (Fresnel effect) creates the "rim light" feel of metal
                float fresnel = dot(viewDir, normal);
                fresnel = clamp(1.0 - fresnel, 0.0, 1.0);
                
                // Create the iridescent look by mixing colors based on normal, view angle, and noise
                
                // 1. Base mix: Chrome to Color1 (Gold) based on noise
                vec3 baseColor = mix(uColorBase, uColor1, smoothstep(-0.5, 0.5, vNoise));
                
                // 2. Add swirls of Color2 (Cyan) and Color3 (Magenta) based on Fresnel and twisted noise
                float swirl = sin(fresnel * 10.0 + uTime + vNoise * 5.0);
                vec3 iridescent = mix(uColor2, uColor3, swirl * 0.5 + 0.5);
                
                // 3. Combine base and iridescence
                // The Fresnel term controls where the iridescence appears (edges vs center)
                vec3 finalColor = mix(baseColor, iridescent, pow(fresnel, 2.0) * uMetallic);
                
                // 4. Specular highlights (shiny plastic/metal look)
                float specular = pow(fresnel, 3.0) * 1.5 * (1.0 - uRoughness);
                finalColor += vec3(specular);
                
                // 5. Add glow effect
                finalColor += iridescent * uGlow * pow(fresnel, 1.5);

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- 4. Geometry & Material ---
        // Icosahedron with high detail (subdivision 64) for smooth liquid deformation
        const geometry = new THREE.IcosahedronGeometry(1.2, 40); 

        // Default Params
        const config = {
            baseColor: '#1a1a26',
            color1: '#ffd700',
            color2: '#00ffff',
            color3: '#ff00ff',
            speed: 1.0,
            noiseScale: 1.5,
            noiseStrength: 0.4,
            rotationSpeed: 2.0,
            metallic: 1.0,
            glow: 0.3,
            scale: 1.2,
            roughness: 0.5,
            preset: 'Custom'
        };
        
        const presets = {
            'Glass': { metallic: 0.2, roughness: 0.1, glow: 0.1 },
            'Chrome': { metallic: 2.0, roughness: 0.0, glow: 0.0 },
            'Matte': { metallic: 0.3, roughness: 0.9, glow: 0.0 },
            'Neon': { metallic: 0.5, roughness: 0.3, glow: 0.8 },
            'Custom': {}
        };

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uDistortion: { value: 1.0 },
                uNoiseScale: { value: config.noiseScale },
                uNoiseStrength: { value: config.noiseStrength },
                uColorBase: { value: new THREE.Color(config.baseColor) },
                uColor1: { value: new THREE.Color(config.color1) },
                uColor2: { value: new THREE.Color(config.color2) },
                uColor3: { value: new THREE.Color(config.color3) },
                uMetallic: { value: config.metallic },
                uGlow: { value: config.glow },
                uRoughness: { value: config.roughness }
            },
            side: THREE.DoubleSide
        });

        const blob = new THREE.Mesh(geometry, material);
        blob.scale.setScalar(config.scale);
        scene.add(blob);

        // --- 2. Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = config.rotationSpeed;

        // --- 5. GUI Integration ---
        const gui = new lil.GUI({ title: 'Blob Generator' });
        
        const actions = {
            exportConfig: () => {
                const data = JSON.stringify(config, null, 2);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `blob_config_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },
            exportID: async () => {
                const id = Date.now();
                const configData = JSON.stringify(config, null, 2);
                
                renderer.render(scene, camera);
                const imgData = await fetch(renderer.domElement.toDataURL('image/png')).then(r => r.blob());
                
                // Generate React component code
                const reactCode = `// Generated Blob Configuration - ID: ${id}
// Import this in your React app and use with InteractiveBlob component

export const blobConfig_${id} = {
  size: ${Math.round(config.scale * 120)},
  color: '${config.color1}',
  // Full shader configuration
  shaderConfig: ${JSON.stringify({
    baseColor: config.baseColor,
    color1: config.color1,
    color2: config.color2,
    color3: config.color3,
    speed: config.speed,
    noiseScale: config.noiseScale,
    noiseStrength: config.noiseStrength,
    rotationSpeed: config.rotationSpeed,
    metallic: config.metallic,
    glow: config.glow,
    roughness: config.roughness,
    scale: config.scale
  }, null, 2)}
};

// Usage example:
// <InteractiveBlob size={blobConfig_${id}.size} color={blobConfig_${id}.color} />
`;
                
                const zip = new JSZip();
                zip.file(`blob_${id}_config.json`, configData);
                zip.file(`blob_${id}_react.ts`, reactCode);
                zip.file(`blob_${id}_screenshot.png`, imgData);
                
                const content = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `blob_${id}.zip`;
                a.click();
                URL.revokeObjectURL(url);
            },
            importConfig: () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = e => {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = event => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            Object.assign(config, imported);
                            updateAllUniforms();
                            gui.controllersRecursive().forEach(c => c.updateDisplay());
                        } catch (err) {
                            alert('Invalid config file');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            },
            screenshot: () => {
                renderer.render(scene, camera);
                const url = renderer.domElement.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url;
                a.download = `blob_${Date.now()}.png`;
                a.click();
            }
        };
        
        actions.exportIcon = () => {
            // Render blob at icon size
            const iconSize = 512;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = iconSize;
            tempCanvas.height = iconSize;
            
            const tempRenderer = new THREE.WebGLRenderer({ canvas: tempCanvas, alpha: true, antialias: true });
            tempRenderer.setSize(iconSize, iconSize);
            tempRenderer.setClearColor(0x000000, 0);
            
            const tempCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            tempCamera.position.copy(camera.position);
            tempCamera.lookAt(scene.position);
            
            tempRenderer.render(scene, tempCamera);
            
            const url = tempCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = url;
            a.download = `blob_icon_${Date.now()}.png`;
            a.click();
            
            tempRenderer.dispose();
        };
        
        gui.add(actions, 'exportID').name('ðŸ†” Export for React App');
        gui.add(actions, 'exportIcon').name('ðŸŽ¨ Export as Icon (512px)');
        gui.add(actions, 'exportConfig').name('ðŸ“¦ Export Config Only');
        gui.add(actions, 'importConfig').name('ðŸ“‚ Import Config');
        gui.add(actions, 'screenshot').name('ðŸ“¸ Screenshot');
        
        const folderAppearance = gui.addFolder('Appearance');
        folderAppearance.add(config, 'speed', 0.1, 5.0).name('Flow Speed');
        folderAppearance.add(config, 'rotationSpeed', 0, 2.0).name('Rotation Speed').onChange(v => controls.autoRotateSpeed = v);
        folderAppearance.add(config, 'noiseScale', 0.5, 5.0).name('Complexity').onChange(v => material.uniforms.uNoiseScale.value = v);
        folderAppearance.add(config, 'noiseStrength', 0.1, 1.0).name('Distortion').onChange(v => material.uniforms.uNoiseStrength.value = v);
        folderAppearance.add(config, 'scale', 0.5, 3.0).name('Size').onChange(v => blob.scale.setScalar(v));
        
        const folderMaterial = gui.addFolder('Material');
        folderMaterial.add(config, 'preset', Object.keys(presets)).name('Preset').onChange(v => {
            if (v !== 'Custom') {
                Object.assign(config, presets[v]);
                updateAllUniforms();
                gui.controllersRecursive().forEach(c => c.updateDisplay());
            }
        });
        folderMaterial.add(config, 'metallic', 0, 2.0).name('Metallic').onChange(v => {
            material.uniforms.uMetallic.value = v;
            config.preset = 'Custom';
            gui.controllersRecursive().forEach(c => c.updateDisplay());
        });
        folderMaterial.add(config, 'roughness', 0, 1.0).name('Roughness').onChange(v => {
            material.uniforms.uRoughness.value = v;
            config.preset = 'Custom';
            gui.controllersRecursive().forEach(c => c.updateDisplay());
        });
        folderMaterial.add(config, 'glow', 0, 1.0).name('Glow').onChange(v => {
            material.uniforms.uGlow.value = v;
            config.preset = 'Custom';
            gui.controllersRecursive().forEach(c => c.updateDisplay());
        });

        const folderColors = gui.addFolder('Palette');
        folderColors.addColor(config, 'baseColor').name('Base/Shadow').onChange(v => material.uniforms.uColorBase.value.set(v));
        folderColors.addColor(config, 'color1').name('Primary').onChange(v => material.uniforms.uColor1.value.set(v));
        folderColors.addColor(config, 'color2').name('Secondary').onChange(v => material.uniforms.uColor2.value.set(v));
        folderColors.addColor(config, 'color3').name('Accent').onChange(v => material.uniforms.uColor3.value.set(v));
        
        function updateAllUniforms() {
            material.uniforms.uNoiseScale.value = config.noiseScale;
            material.uniforms.uNoiseStrength.value = config.noiseStrength;
            material.uniforms.uColorBase.value.set(config.baseColor);
            material.uniforms.uColor1.value.set(config.color1);
            material.uniforms.uColor2.value.set(config.color2);
            material.uniforms.uColor3.value.set(config.color3);
            material.uniforms.uMetallic.value = config.metallic;
            material.uniforms.uGlow.value = config.glow;
            material.uniforms.uRoughness.value = config.roughness;
            blob.scale.setScalar(config.scale);
            controls.autoRotateSpeed = config.rotationSpeed;
        }


        // --- 6. Interaction Logic ---
        // REMOVED mousemove rotation logic to fix jitter and improve stability
        
        let isDragging = false;
        let targetDistortion = 1.0; // By default, it's distorted (melted)

        // Mouse Down/Up Listener for "Rounding" effect
        document.addEventListener('mousedown', () => {
            isDragging = true;
            targetDistortion = 0.0; // Smooth out
            controls.autoRotate = false; // Stop spinning while grabbing
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            targetDistortion = 1.0; // Melt again
            controls.autoRotate = true; // Resume spin
        });

        // Touch support for mobile
        document.addEventListener('touchstart', () => {
            isDragging = true;
            targetDistortion = 0.0;
            controls.autoRotate = false;
        });
        document.addEventListener('touchend', () => {
            isDragging = false;
            targetDistortion = 1.0;
            controls.autoRotate = true;
        });


        // --- 7. Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            // Use user-defined speed
            material.uniforms.uTime.value += delta * config.speed;

            // Smoothly interpolate distortion value
            // This creates the satisfying transition from "melted" to "round"
            material.uniforms.uDistortion.value += (targetDistortion - material.uniforms.uDistortion.value) * 0.1;

            // Update controls
            controls.update();

            renderer.render(scene, camera);
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>