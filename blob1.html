<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Gradient Blob</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* Very dark background to pop colors */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            font-size: 14px;
            mix-blend-mode: difference;
        }
    </style>
</head>
<body>
    <div id="ui">Move cursor to interact â€¢ Hover to agitate</div>
    <script>
        // --- Configuration ---
        const CONFIG = {
            noiseSpeed: 0.2,
            noiseStrength: 0.3,
            color1: new THREE.Color(0x3e20e8), // Deep Blue/Purple
            color2: new THREE.Color(0xff0075), // Hot Pink
            color3: new THREE.Color(0x00fff2), // Cyan/Teal
            bgColor: 0x050505
        };

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(CONFIG.bgColor);
        scene.fog = new THREE.Fog(CONFIG.bgColor, 5, 15);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.z = 4;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance optimization
        document.body.appendChild(renderer.domElement);

        // --- Shader Material (The Magic) ---
        // We use a custom shader to displace vertices using Simplex Noise
        
        const vertexShader = `
            uniform float uTime;
            uniform float uHover;
            uniform vec2 uMouse;
            uniform float uNoiseStrength;

            varying vec2 vUv;
            varying float vDistortion;
            varying vec3 vNormal;

            // Simplex 3D Noise 
            // defined by: Ian McEwan, Ashima Arts
            vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
            vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

            float snoise(vec3 v){ 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;

                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );

                //  x0 = x0 - 0.0 + 0.0 * C 
                vec3 x1 = x0 - i1 + 1.0 * C.xxx;
                vec3 x2 = x0 - i2 + 2.0 * C.xxx;
                vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;

                // Permutations
                i = mod(i, 289.0 ); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

                // Gradients
                // ( N*N points uniformly over a square, mapped onto an octahedron.)
                float n_ = 1.0/7.0; // N=7
                vec3  ns = n_ * D.wyz - D.xzx;

                vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);

                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );

                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));

                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);

                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;

                // Mix final noise value
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                            dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vUv = uv;
                vNormal = normal;

                // Interaction Influence
                // Calculate distance from this vertex to a point influenced by mouse (simplified as direction)
                // For a true 3D mouse interaction, we usually raycast, but for this effect, 
                // we'll just modify the noise frequency/amplitude based on global 'hover' state.
                
                float noiseFreq = 1.5 + (uHover * 1.0); // Increase frequency on hover
                float noiseAmp = uNoiseStrength + (uHover * 0.2); // Increase amplitude on hover

                // Get Noise
                vec3 pos = position;
                float noiseVal = snoise(vec3(pos.x * noiseFreq + uTime, pos.y * noiseFreq + uTime, pos.z * noiseFreq));
                
                // Displace
                vec3 newPos = position + normal * noiseVal * noiseAmp;
                
                vDistortion = noiseVal; // Pass to fragment for coloring
                
                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            
            varying float vDistortion;
            varying vec3 vNormal;
            varying vec2 vUv;

            void main() {
                // Mix colors based on distortion
                // vDistortion is roughly -1 to 1. We map it to 0-1.
                float distort = (vDistortion * 0.5) + 0.5;

                // Create a gradient: Color1 -> Color2 -> Color3
                vec3 finalColor = mix(uColor1, uColor2, distort);
                finalColor = mix(finalColor, uColor3, distort * distort); // Add highlights

                // Fresnel Effect (Rim lighting)
                // Makes the edges glow, enhancing the 3D feel
                vec3 viewDir = vec3(0.0, 0.0, 1.0); // Simplified view direction
                float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);

                // Add Fresnel glow
                finalColor += fresnel * 0.3;

                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        const uniforms = {
            uTime: { value: 0.0 },
            uHover: { value: 0.0 }, // 0 to 1
            uMouse: { value: new THREE.Vector2(0, 0) },
            uNoiseStrength: { value: CONFIG.noiseStrength },
            uColor1: { value: CONFIG.color1 },
            uColor2: { value: CONFIG.color2 },
            uColor3: { value: CONFIG.color3 }
        };

        const material = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: uniforms,
            wireframe: false
        });

        // --- Geometry ---
        // Icosahedron with high detail for smooth deformation
        const geometry = new THREE.IcosahedronGeometry(1.5, 64);
        const blob = new THREE.Mesh(geometry, material);
        scene.add(blob);

        // --- Lighting (Optional, mostly baked into shader but good for standard objects) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // --- Input Handling ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        let hoverStrength = 0;

        // Use standard event listeners for mouse
        document.addEventListener('mousemove', (e) => {
            const windowHalfX = window.innerWidth / 2;
            const windowHalfY = window.innerHeight / 2;

            mouseX = (e.clientX - windowHalfX) / 100;
            mouseY = (e.clientY - windowHalfY) / 100;
            
            // Calculate hover intensity (center of screen)
            // Normalized distance from center (0 to 1)
            let dist = Math.sqrt(Math.pow((e.clientX - windowHalfX)/windowHalfX, 2) + Math.pow((e.clientY - windowHalfY)/windowHalfY, 2));
            // Invert: 1 at center, 0 at edges
            hoverStrength = Math.max(0, 1 - dist); 
        });

        // Touch support
        document.addEventListener('touchmove', (e) => {
            if(e.touches.length > 0) {
                const windowHalfX = window.innerWidth / 2;
                const windowHalfY = window.innerHeight / 2;
                mouseX = (e.touches[0].clientX - windowHalfX) / 100;
                mouseY = (e.touches[0].clientY - windowHalfY) / 100;
                
                 let dist = Math.sqrt(Math.pow((e.touches[0].clientX - windowHalfX)/windowHalfX, 2) + Math.pow((e.touches[0].clientY - windowHalfY)/windowHalfY, 2));
                hoverStrength = Math.max(0, 1 - dist);
            }
        }, { passive: false });


        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Smooth mouse follow (Linear Interpolation)
            targetX = mouseX * 0.5;
            targetY = mouseY * 0.5;

            // Rotation follows mouse
            blob.rotation.y += 0.05 * (targetX - blob.rotation.y);
            blob.rotation.x += 0.05 * (targetY - blob.rotation.x);

            // Update Uniforms
            // Basic continuous flow
            blob.material.uniforms.uTime.value = elapsedTime * CONFIG.noiseSpeed;
            
            // Interaction: Increase speed slightly based on hover
            blob.material.uniforms.uTime.value += hoverStrength * 0.05;

            // Smoothly update hover value in shader
            blob.material.uniforms.uHover.value = THREE.MathUtils.lerp(
                blob.material.uniforms.uHover.value, 
                hoverStrength, 
                0.1
            );

            renderer.render(scene, camera);
        }

        // --- Resize Handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>